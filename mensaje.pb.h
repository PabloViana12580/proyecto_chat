// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mensaje.proto

#ifndef PROTOBUF_INCLUDED_mensaje_2eproto
#define PROTOBUF_INCLUDED_mensaje_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mensaje_2eproto 

namespace protobuf_mensaje_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mensaje_2eproto
namespace chat {
class BroadcastMessage;
class BroadcastMessageDefaultTypeInternal;
extern BroadcastMessageDefaultTypeInternal _BroadcastMessage_default_instance_;
class BroadcastRequest;
class BroadcastRequestDefaultTypeInternal;
extern BroadcastRequestDefaultTypeInternal _BroadcastRequest_default_instance_;
class BroadcastResponse;
class BroadcastResponseDefaultTypeInternal;
extern BroadcastResponseDefaultTypeInternal _BroadcastResponse_default_instance_;
class ChangeStatusRequest;
class ChangeStatusRequestDefaultTypeInternal;
extern ChangeStatusRequestDefaultTypeInternal _ChangeStatusRequest_default_instance_;
class ChangeStatusResponse;
class ChangeStatusResponseDefaultTypeInternal;
extern ChangeStatusResponseDefaultTypeInternal _ChangeStatusResponse_default_instance_;
class ClientMessage;
class ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class ConnectedUser;
class ConnectedUserDefaultTypeInternal;
extern ConnectedUserDefaultTypeInternal _ConnectedUser_default_instance_;
class ConnectedUserResponse;
class ConnectedUserResponseDefaultTypeInternal;
extern ConnectedUserResponseDefaultTypeInternal _ConnectedUserResponse_default_instance_;
class DirectMessage;
class DirectMessageDefaultTypeInternal;
extern DirectMessageDefaultTypeInternal _DirectMessage_default_instance_;
class DirectMessageRequest;
class DirectMessageRequestDefaultTypeInternal;
extern DirectMessageRequestDefaultTypeInternal _DirectMessageRequest_default_instance_;
class DirectMessageResponse;
class DirectMessageResponseDefaultTypeInternal;
extern DirectMessageResponseDefaultTypeInternal _DirectMessageResponse_default_instance_;
class ErrorResponse;
class ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class MyInfoAcknowledge;
class MyInfoAcknowledgeDefaultTypeInternal;
extern MyInfoAcknowledgeDefaultTypeInternal _MyInfoAcknowledge_default_instance_;
class MyInfoResponse;
class MyInfoResponseDefaultTypeInternal;
extern MyInfoResponseDefaultTypeInternal _MyInfoResponse_default_instance_;
class MyInfoSynchronize;
class MyInfoSynchronizeDefaultTypeInternal;
extern MyInfoSynchronizeDefaultTypeInternal _MyInfoSynchronize_default_instance_;
class ServerMessage;
class ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class connectedUserRequest;
class connectedUserRequestDefaultTypeInternal;
extern connectedUserRequestDefaultTypeInternal _connectedUserRequest_default_instance_;
}  // namespace chat
namespace google {
namespace protobuf {
template<> ::chat::BroadcastMessage* Arena::CreateMaybeMessage<::chat::BroadcastMessage>(Arena*);
template<> ::chat::BroadcastRequest* Arena::CreateMaybeMessage<::chat::BroadcastRequest>(Arena*);
template<> ::chat::BroadcastResponse* Arena::CreateMaybeMessage<::chat::BroadcastResponse>(Arena*);
template<> ::chat::ChangeStatusRequest* Arena::CreateMaybeMessage<::chat::ChangeStatusRequest>(Arena*);
template<> ::chat::ChangeStatusResponse* Arena::CreateMaybeMessage<::chat::ChangeStatusResponse>(Arena*);
template<> ::chat::ClientMessage* Arena::CreateMaybeMessage<::chat::ClientMessage>(Arena*);
template<> ::chat::ConnectedUser* Arena::CreateMaybeMessage<::chat::ConnectedUser>(Arena*);
template<> ::chat::ConnectedUserResponse* Arena::CreateMaybeMessage<::chat::ConnectedUserResponse>(Arena*);
template<> ::chat::DirectMessage* Arena::CreateMaybeMessage<::chat::DirectMessage>(Arena*);
template<> ::chat::DirectMessageRequest* Arena::CreateMaybeMessage<::chat::DirectMessageRequest>(Arena*);
template<> ::chat::DirectMessageResponse* Arena::CreateMaybeMessage<::chat::DirectMessageResponse>(Arena*);
template<> ::chat::ErrorResponse* Arena::CreateMaybeMessage<::chat::ErrorResponse>(Arena*);
template<> ::chat::MyInfoAcknowledge* Arena::CreateMaybeMessage<::chat::MyInfoAcknowledge>(Arena*);
template<> ::chat::MyInfoResponse* Arena::CreateMaybeMessage<::chat::MyInfoResponse>(Arena*);
template<> ::chat::MyInfoSynchronize* Arena::CreateMaybeMessage<::chat::MyInfoSynchronize>(Arena*);
template<> ::chat::ServerMessage* Arena::CreateMaybeMessage<::chat::ServerMessage>(Arena*);
template<> ::chat::connectedUserRequest* Arena::CreateMaybeMessage<::chat::connectedUserRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chat {

// ===================================================================

class MyInfoSynchronize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoSynchronize) */ {
 public:
  MyInfoSynchronize();
  virtual ~MyInfoSynchronize();

  MyInfoSynchronize(const MyInfoSynchronize& from);

  inline MyInfoSynchronize& operator=(const MyInfoSynchronize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MyInfoSynchronize(MyInfoSynchronize&& from) noexcept
    : MyInfoSynchronize() {
    *this = ::std::move(from);
  }

  inline MyInfoSynchronize& operator=(MyInfoSynchronize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyInfoSynchronize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyInfoSynchronize* internal_default_instance() {
    return reinterpret_cast<const MyInfoSynchronize*>(
               &_MyInfoSynchronize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MyInfoSynchronize* other);
  friend void swap(MyInfoSynchronize& a, MyInfoSynchronize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MyInfoSynchronize* New() const final {
    return CreateMaybeMessage<MyInfoSynchronize>(NULL);
  }

  MyInfoSynchronize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MyInfoSynchronize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MyInfoSynchronize& from);
  void MergeFrom(const MyInfoSynchronize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyInfoSynchronize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:chat.MyInfoSynchronize)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MyInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoResponse) */ {
 public:
  MyInfoResponse();
  virtual ~MyInfoResponse();

  MyInfoResponse(const MyInfoResponse& from);

  inline MyInfoResponse& operator=(const MyInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MyInfoResponse(MyInfoResponse&& from) noexcept
    : MyInfoResponse() {
    *this = ::std::move(from);
  }

  inline MyInfoResponse& operator=(MyInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyInfoResponse* internal_default_instance() {
    return reinterpret_cast<const MyInfoResponse*>(
               &_MyInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MyInfoResponse* other);
  friend void swap(MyInfoResponse& a, MyInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MyInfoResponse* New() const final {
    return CreateMaybeMessage<MyInfoResponse>(NULL);
  }

  MyInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MyInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MyInfoResponse& from);
  void MergeFrom(const MyInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.MyInfoResponse)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MyInfoAcknowledge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoAcknowledge) */ {
 public:
  MyInfoAcknowledge();
  virtual ~MyInfoAcknowledge();

  MyInfoAcknowledge(const MyInfoAcknowledge& from);

  inline MyInfoAcknowledge& operator=(const MyInfoAcknowledge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MyInfoAcknowledge(MyInfoAcknowledge&& from) noexcept
    : MyInfoAcknowledge() {
    *this = ::std::move(from);
  }

  inline MyInfoAcknowledge& operator=(MyInfoAcknowledge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyInfoAcknowledge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyInfoAcknowledge* internal_default_instance() {
    return reinterpret_cast<const MyInfoAcknowledge*>(
               &_MyInfoAcknowledge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MyInfoAcknowledge* other);
  friend void swap(MyInfoAcknowledge& a, MyInfoAcknowledge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MyInfoAcknowledge* New() const final {
    return CreateMaybeMessage<MyInfoAcknowledge>(NULL);
  }

  MyInfoAcknowledge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MyInfoAcknowledge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MyInfoAcknowledge& from);
  void MergeFrom(const MyInfoAcknowledge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyInfoAcknowledge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.MyInfoAcknowledge)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class connectedUserRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.connectedUserRequest) */ {
 public:
  connectedUserRequest();
  virtual ~connectedUserRequest();

  connectedUserRequest(const connectedUserRequest& from);

  inline connectedUserRequest& operator=(const connectedUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  connectedUserRequest(connectedUserRequest&& from) noexcept
    : connectedUserRequest() {
    *this = ::std::move(from);
  }

  inline connectedUserRequest& operator=(connectedUserRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connectedUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const connectedUserRequest* internal_default_instance() {
    return reinterpret_cast<const connectedUserRequest*>(
               &_connectedUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(connectedUserRequest* other);
  friend void swap(connectedUserRequest& a, connectedUserRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline connectedUserRequest* New() const final {
    return CreateMaybeMessage<connectedUserRequest>(NULL);
  }

  connectedUserRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<connectedUserRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const connectedUserRequest& from);
  void MergeFrom(const connectedUserRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(connectedUserRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.connectedUserRequest)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_username();
  void clear_has_username();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectedUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUser) */ {
 public:
  ConnectedUser();
  virtual ~ConnectedUser();

  ConnectedUser(const ConnectedUser& from);

  inline ConnectedUser& operator=(const ConnectedUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectedUser(ConnectedUser&& from) noexcept
    : ConnectedUser() {
    *this = ::std::move(from);
  }

  inline ConnectedUser& operator=(ConnectedUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectedUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectedUser* internal_default_instance() {
    return reinterpret_cast<const ConnectedUser*>(
               &_ConnectedUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ConnectedUser* other);
  friend void swap(ConnectedUser& a, ConnectedUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectedUser* New() const final {
    return CreateMaybeMessage<ConnectedUser>(NULL);
  }

  ConnectedUser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectedUser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectedUser& from);
  void MergeFrom(const ConnectedUser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectedUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // optional string ip = 4;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 4;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional int32 userId = 3;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.ConnectedUser)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_status();
  void clear_has_status();
  void set_has_userid();
  void clear_has_userid();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectedUserResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUserResponse) */ {
 public:
  ConnectedUserResponse();
  virtual ~ConnectedUserResponse();

  ConnectedUserResponse(const ConnectedUserResponse& from);

  inline ConnectedUserResponse& operator=(const ConnectedUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectedUserResponse(ConnectedUserResponse&& from) noexcept
    : ConnectedUserResponse() {
    *this = ::std::move(from);
  }

  inline ConnectedUserResponse& operator=(ConnectedUserResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectedUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectedUserResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectedUserResponse*>(
               &_ConnectedUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ConnectedUserResponse* other);
  friend void swap(ConnectedUserResponse& a, ConnectedUserResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectedUserResponse* New() const final {
    return CreateMaybeMessage<ConnectedUserResponse>(NULL);
  }

  ConnectedUserResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectedUserResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectedUserResponse& from);
  void MergeFrom(const ConnectedUserResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectedUserResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chat.ConnectedUser connectedUsers = 1;
  int connectedusers_size() const;
  void clear_connectedusers();
  static const int kConnectedUsersFieldNumber = 1;
  ::chat::ConnectedUser* mutable_connectedusers(int index);
  ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >*
      mutable_connectedusers();
  const ::chat::ConnectedUser& connectedusers(int index) const;
  ::chat::ConnectedUser* add_connectedusers();
  const ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >&
      connectedusers() const;

  // @@protoc_insertion_point(class_scope:chat.ConnectedUserResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser > connectedusers_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangeStatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatusRequest) */ {
 public:
  ChangeStatusRequest();
  virtual ~ChangeStatusRequest();

  ChangeStatusRequest(const ChangeStatusRequest& from);

  inline ChangeStatusRequest& operator=(const ChangeStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeStatusRequest(ChangeStatusRequest&& from) noexcept
    : ChangeStatusRequest() {
    *this = ::std::move(from);
  }

  inline ChangeStatusRequest& operator=(ChangeStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusRequest*>(
               &_ChangeStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ChangeStatusRequest* other);
  friend void swap(ChangeStatusRequest& a, ChangeStatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusRequest* New() const final {
    return CreateMaybeMessage<ChangeStatusRequest>(NULL);
  }

  ChangeStatusRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeStatusRequest& from);
  void MergeFrom(const ChangeStatusRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:chat.ChangeStatusRequest)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangeStatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatusResponse) */ {
 public:
  ChangeStatusResponse();
  virtual ~ChangeStatusResponse();

  ChangeStatusResponse(const ChangeStatusResponse& from);

  inline ChangeStatusResponse& operator=(const ChangeStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeStatusResponse(ChangeStatusResponse&& from) noexcept
    : ChangeStatusResponse() {
    *this = ::std::move(from);
  }

  inline ChangeStatusResponse& operator=(ChangeStatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusResponse*>(
               &_ChangeStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ChangeStatusResponse* other);
  friend void swap(ChangeStatusResponse& a, ChangeStatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusResponse* New() const final {
    return CreateMaybeMessage<ChangeStatusResponse>(NULL);
  }

  ChangeStatusResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeStatusResponse& from);
  void MergeFrom(const ChangeStatusResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.ChangeStatusResponse)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BroadcastRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastRequest) */ {
 public:
  BroadcastRequest();
  virtual ~BroadcastRequest();

  BroadcastRequest(const BroadcastRequest& from);

  inline BroadcastRequest& operator=(const BroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BroadcastRequest(BroadcastRequest&& from) noexcept
    : BroadcastRequest() {
    *this = ::std::move(from);
  }

  inline BroadcastRequest& operator=(BroadcastRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastRequest* internal_default_instance() {
    return reinterpret_cast<const BroadcastRequest*>(
               &_BroadcastRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BroadcastRequest* other);
  friend void swap(BroadcastRequest& a, BroadcastRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BroadcastRequest* New() const final {
    return CreateMaybeMessage<BroadcastRequest>(NULL);
  }

  BroadcastRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BroadcastRequest& from);
  void MergeFrom(const BroadcastRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:chat.BroadcastRequest)
 private:
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BroadcastResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastResponse) */ {
 public:
  BroadcastResponse();
  virtual ~BroadcastResponse();

  BroadcastResponse(const BroadcastResponse& from);

  inline BroadcastResponse& operator=(const BroadcastResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BroadcastResponse(BroadcastResponse&& from) noexcept
    : BroadcastResponse() {
    *this = ::std::move(from);
  }

  inline BroadcastResponse& operator=(BroadcastResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastResponse* internal_default_instance() {
    return reinterpret_cast<const BroadcastResponse*>(
               &_BroadcastResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(BroadcastResponse* other);
  friend void swap(BroadcastResponse& a, BroadcastResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BroadcastResponse* New() const final {
    return CreateMaybeMessage<BroadcastResponse>(NULL);
  }

  BroadcastResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BroadcastResponse& from);
  void MergeFrom(const BroadcastResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageStatus = 1;
  bool has_messagestatus() const;
  void clear_messagestatus();
  static const int kMessageStatusFieldNumber = 1;
  const ::std::string& messagestatus() const;
  void set_messagestatus(const ::std::string& value);
  #if LANG_CXX11
  void set_messagestatus(::std::string&& value);
  #endif
  void set_messagestatus(const char* value);
  void set_messagestatus(const char* value, size_t size);
  ::std::string* mutable_messagestatus();
  ::std::string* release_messagestatus();
  void set_allocated_messagestatus(::std::string* messagestatus);

  // @@protoc_insertion_point(class_scope:chat.BroadcastResponse)
 private:
  void set_has_messagestatus();
  void clear_has_messagestatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagestatus_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BroadcastMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastMessage) */ {
 public:
  BroadcastMessage();
  virtual ~BroadcastMessage();

  BroadcastMessage(const BroadcastMessage& from);

  inline BroadcastMessage& operator=(const BroadcastMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BroadcastMessage(BroadcastMessage&& from) noexcept
    : BroadcastMessage() {
    *this = ::std::move(from);
  }

  inline BroadcastMessage& operator=(BroadcastMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastMessage* internal_default_instance() {
    return reinterpret_cast<const BroadcastMessage*>(
               &_BroadcastMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BroadcastMessage* other);
  friend void swap(BroadcastMessage& a, BroadcastMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BroadcastMessage* New() const final {
    return CreateMaybeMessage<BroadcastMessage>(NULL);
  }

  BroadcastMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BroadcastMessage& from);
  void MergeFrom(const BroadcastMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string username = 3;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.BroadcastMessage)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_userid();
  void clear_has_userid();
  void set_has_username();
  void clear_has_username();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessageRequest) */ {
 public:
  DirectMessageRequest();
  virtual ~DirectMessageRequest();

  DirectMessageRequest(const DirectMessageRequest& from);

  inline DirectMessageRequest& operator=(const DirectMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectMessageRequest(DirectMessageRequest&& from) noexcept
    : DirectMessageRequest() {
    *this = ::std::move(from);
  }

  inline DirectMessageRequest& operator=(DirectMessageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectMessageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectMessageRequest* internal_default_instance() {
    return reinterpret_cast<const DirectMessageRequest*>(
               &_DirectMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DirectMessageRequest* other);
  friend void swap(DirectMessageRequest& a, DirectMessageRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectMessageRequest* New() const final {
    return CreateMaybeMessage<DirectMessageRequest>(NULL);
  }

  DirectMessageRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectMessageRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectMessageRequest& from);
  void MergeFrom(const DirectMessageRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string username = 3;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.DirectMessageRequest)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_userid();
  void clear_has_userid();
  void set_has_username();
  void clear_has_username();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectMessageResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessageResponse) */ {
 public:
  DirectMessageResponse();
  virtual ~DirectMessageResponse();

  DirectMessageResponse(const DirectMessageResponse& from);

  inline DirectMessageResponse& operator=(const DirectMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectMessageResponse(DirectMessageResponse&& from) noexcept
    : DirectMessageResponse() {
    *this = ::std::move(from);
  }

  inline DirectMessageResponse& operator=(DirectMessageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectMessageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectMessageResponse* internal_default_instance() {
    return reinterpret_cast<const DirectMessageResponse*>(
               &_DirectMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DirectMessageResponse* other);
  friend void swap(DirectMessageResponse& a, DirectMessageResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectMessageResponse* New() const final {
    return CreateMaybeMessage<DirectMessageResponse>(NULL);
  }

  DirectMessageResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectMessageResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectMessageResponse& from);
  void MergeFrom(const DirectMessageResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMessageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageStatus = 1;
  bool has_messagestatus() const;
  void clear_messagestatus();
  static const int kMessageStatusFieldNumber = 1;
  const ::std::string& messagestatus() const;
  void set_messagestatus(const ::std::string& value);
  #if LANG_CXX11
  void set_messagestatus(::std::string&& value);
  #endif
  void set_messagestatus(const char* value);
  void set_messagestatus(const char* value, size_t size);
  ::std::string* mutable_messagestatus();
  ::std::string* release_messagestatus();
  void set_allocated_messagestatus(::std::string* messagestatus);

  // @@protoc_insertion_point(class_scope:chat.DirectMessageResponse)
 private:
  void set_has_messagestatus();
  void clear_has_messagestatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagestatus_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessage) */ {
 public:
  DirectMessage();
  virtual ~DirectMessage();

  DirectMessage(const DirectMessage& from);

  inline DirectMessage& operator=(const DirectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectMessage(DirectMessage&& from) noexcept
    : DirectMessage() {
    *this = ::std::move(from);
  }

  inline DirectMessage& operator=(DirectMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectMessage* internal_default_instance() {
    return reinterpret_cast<const DirectMessage*>(
               &_DirectMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(DirectMessage* other);
  friend void swap(DirectMessage& a, DirectMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectMessage* New() const final {
    return CreateMaybeMessage<DirectMessage>(NULL);
  }

  DirectMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectMessage& from);
  void MergeFrom(const DirectMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string username = 3;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.DirectMessage)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_userid();
  void clear_has_userid();
  void set_has_username();
  void clear_has_username();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ErrorResponse) */ {
 public:
  ErrorResponse();
  virtual ~ErrorResponse();

  ErrorResponse(const ErrorResponse& from);

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ErrorResponse* other);
  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const final {
    return CreateMaybeMessage<ErrorResponse>(NULL);
  }

  ErrorResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errorMessage = 1;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 1;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // @@protoc_insertion_point(class_scope:chat.ErrorResponse)
 private:
  void set_has_errormessage();
  void clear_has_errormessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ClientMessage) */ {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ClientMessage* other);
  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage* New() const final {
    return CreateMaybeMessage<ClientMessage>(NULL);
  }

  ClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chat.MyInfoSynchronize synchronize = 3;
  bool has_synchronize() const;
  void clear_synchronize();
  static const int kSynchronizeFieldNumber = 3;
  private:
  const ::chat::MyInfoSynchronize& _internal_synchronize() const;
  public:
  const ::chat::MyInfoSynchronize& synchronize() const;
  ::chat::MyInfoSynchronize* release_synchronize();
  ::chat::MyInfoSynchronize* mutable_synchronize();
  void set_allocated_synchronize(::chat::MyInfoSynchronize* synchronize);

  // optional .chat.connectedUserRequest connectedUsers = 4;
  bool has_connectedusers() const;
  void clear_connectedusers();
  static const int kConnectedUsersFieldNumber = 4;
  private:
  const ::chat::connectedUserRequest& _internal_connectedusers() const;
  public:
  const ::chat::connectedUserRequest& connectedusers() const;
  ::chat::connectedUserRequest* release_connectedusers();
  ::chat::connectedUserRequest* mutable_connectedusers();
  void set_allocated_connectedusers(::chat::connectedUserRequest* connectedusers);

  // optional .chat.ChangeStatusRequest changeStatus = 5;
  bool has_changestatus() const;
  void clear_changestatus();
  static const int kChangeStatusFieldNumber = 5;
  private:
  const ::chat::ChangeStatusRequest& _internal_changestatus() const;
  public:
  const ::chat::ChangeStatusRequest& changestatus() const;
  ::chat::ChangeStatusRequest* release_changestatus();
  ::chat::ChangeStatusRequest* mutable_changestatus();
  void set_allocated_changestatus(::chat::ChangeStatusRequest* changestatus);

  // optional .chat.BroadcastRequest broadcast = 6;
  bool has_broadcast() const;
  void clear_broadcast();
  static const int kBroadcastFieldNumber = 6;
  private:
  const ::chat::BroadcastRequest& _internal_broadcast() const;
  public:
  const ::chat::BroadcastRequest& broadcast() const;
  ::chat::BroadcastRequest* release_broadcast();
  ::chat::BroadcastRequest* mutable_broadcast();
  void set_allocated_broadcast(::chat::BroadcastRequest* broadcast);

  // optional .chat.DirectMessageRequest directMessage = 7;
  bool has_directmessage() const;
  void clear_directmessage();
  static const int kDirectMessageFieldNumber = 7;
  private:
  const ::chat::DirectMessageRequest& _internal_directmessage() const;
  public:
  const ::chat::DirectMessageRequest& directmessage() const;
  ::chat::DirectMessageRequest* release_directmessage();
  ::chat::DirectMessageRequest* mutable_directmessage();
  void set_allocated_directmessage(::chat::DirectMessageRequest* directmessage);

  // optional .chat.MyInfoAcknowledge acknowledge = 8;
  bool has_acknowledge() const;
  void clear_acknowledge();
  static const int kAcknowledgeFieldNumber = 8;
  private:
  const ::chat::MyInfoAcknowledge& _internal_acknowledge() const;
  public:
  const ::chat::MyInfoAcknowledge& acknowledge() const;
  ::chat::MyInfoAcknowledge* release_acknowledge();
  ::chat::MyInfoAcknowledge* mutable_acknowledge();
  void set_allocated_acknowledge(::chat::MyInfoAcknowledge* acknowledge);

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // optional int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.ClientMessage)
 private:
  void set_has_option();
  void clear_has_option();
  void set_has_userid();
  void clear_has_userid();
  void set_has_synchronize();
  void clear_has_synchronize();
  void set_has_connectedusers();
  void clear_has_connectedusers();
  void set_has_changestatus();
  void clear_has_changestatus();
  void set_has_broadcast();
  void clear_has_broadcast();
  void set_has_directmessage();
  void clear_has_directmessage();
  void set_has_acknowledge();
  void clear_has_acknowledge();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::chat::MyInfoSynchronize* synchronize_;
  ::chat::connectedUserRequest* connectedusers_;
  ::chat::ChangeStatusRequest* changestatus_;
  ::chat::BroadcastRequest* broadcast_;
  ::chat::DirectMessageRequest* directmessage_;
  ::chat::MyInfoAcknowledge* acknowledge_;
  ::google::protobuf::int32 option_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ServerMessage) */ {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ServerMessage* other);
  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const final {
    return CreateMaybeMessage<ServerMessage>(NULL);
  }

  ServerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chat.BroadcastMessage broadcast = 2;
  bool has_broadcast() const;
  void clear_broadcast();
  static const int kBroadcastFieldNumber = 2;
  private:
  const ::chat::BroadcastMessage& _internal_broadcast() const;
  public:
  const ::chat::BroadcastMessage& broadcast() const;
  ::chat::BroadcastMessage* release_broadcast();
  ::chat::BroadcastMessage* mutable_broadcast();
  void set_allocated_broadcast(::chat::BroadcastMessage* broadcast);

  // optional .chat.DirectMessage message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  private:
  const ::chat::DirectMessage& _internal_message() const;
  public:
  const ::chat::DirectMessage& message() const;
  ::chat::DirectMessage* release_message();
  ::chat::DirectMessage* mutable_message();
  void set_allocated_message(::chat::DirectMessage* message);

  // optional .chat.ErrorResponse error = 4;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 4;
  private:
  const ::chat::ErrorResponse& _internal_error() const;
  public:
  const ::chat::ErrorResponse& error() const;
  ::chat::ErrorResponse* release_error();
  ::chat::ErrorResponse* mutable_error();
  void set_allocated_error(::chat::ErrorResponse* error);

  // optional .chat.MyInfoResponse myInfoResponse = 5;
  bool has_myinforesponse() const;
  void clear_myinforesponse();
  static const int kMyInfoResponseFieldNumber = 5;
  private:
  const ::chat::MyInfoResponse& _internal_myinforesponse() const;
  public:
  const ::chat::MyInfoResponse& myinforesponse() const;
  ::chat::MyInfoResponse* release_myinforesponse();
  ::chat::MyInfoResponse* mutable_myinforesponse();
  void set_allocated_myinforesponse(::chat::MyInfoResponse* myinforesponse);

  // optional .chat.ConnectedUserResponse connectedUserResponse = 6;
  bool has_connecteduserresponse() const;
  void clear_connecteduserresponse();
  static const int kConnectedUserResponseFieldNumber = 6;
  private:
  const ::chat::ConnectedUserResponse& _internal_connecteduserresponse() const;
  public:
  const ::chat::ConnectedUserResponse& connecteduserresponse() const;
  ::chat::ConnectedUserResponse* release_connecteduserresponse();
  ::chat::ConnectedUserResponse* mutable_connecteduserresponse();
  void set_allocated_connecteduserresponse(::chat::ConnectedUserResponse* connecteduserresponse);

  // optional .chat.ChangeStatusResponse changeStatusResponse = 7;
  bool has_changestatusresponse() const;
  void clear_changestatusresponse();
  static const int kChangeStatusResponseFieldNumber = 7;
  private:
  const ::chat::ChangeStatusResponse& _internal_changestatusresponse() const;
  public:
  const ::chat::ChangeStatusResponse& changestatusresponse() const;
  ::chat::ChangeStatusResponse* release_changestatusresponse();
  ::chat::ChangeStatusResponse* mutable_changestatusresponse();
  void set_allocated_changestatusresponse(::chat::ChangeStatusResponse* changestatusresponse);

  // optional .chat.BroadcastResponse broadcastResponse = 8;
  bool has_broadcastresponse() const;
  void clear_broadcastresponse();
  static const int kBroadcastResponseFieldNumber = 8;
  private:
  const ::chat::BroadcastResponse& _internal_broadcastresponse() const;
  public:
  const ::chat::BroadcastResponse& broadcastresponse() const;
  ::chat::BroadcastResponse* release_broadcastresponse();
  ::chat::BroadcastResponse* mutable_broadcastresponse();
  void set_allocated_broadcastresponse(::chat::BroadcastResponse* broadcastresponse);

  // optional .chat.DirectMessageResponse directMessageResponse = 9;
  bool has_directmessageresponse() const;
  void clear_directmessageresponse();
  static const int kDirectMessageResponseFieldNumber = 9;
  private:
  const ::chat::DirectMessageResponse& _internal_directmessageresponse() const;
  public:
  const ::chat::DirectMessageResponse& directmessageresponse() const;
  ::chat::DirectMessageResponse* release_directmessageresponse();
  ::chat::DirectMessageResponse* mutable_directmessageresponse();
  void set_allocated_directmessageresponse(::chat::DirectMessageResponse* directmessageresponse);

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.ServerMessage)
 private:
  void set_has_option();
  void clear_has_option();
  void set_has_broadcast();
  void clear_has_broadcast();
  void set_has_message();
  void clear_has_message();
  void set_has_error();
  void clear_has_error();
  void set_has_myinforesponse();
  void clear_has_myinforesponse();
  void set_has_connecteduserresponse();
  void clear_has_connecteduserresponse();
  void set_has_changestatusresponse();
  void clear_has_changestatusresponse();
  void set_has_broadcastresponse();
  void clear_has_broadcastresponse();
  void set_has_directmessageresponse();
  void clear_has_directmessageresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::chat::BroadcastMessage* broadcast_;
  ::chat::DirectMessage* message_;
  ::chat::ErrorResponse* error_;
  ::chat::MyInfoResponse* myinforesponse_;
  ::chat::ConnectedUserResponse* connecteduserresponse_;
  ::chat::ChangeStatusResponse* changestatusresponse_;
  ::chat::BroadcastResponse* broadcastresponse_;
  ::chat::DirectMessageResponse* directmessageresponse_;
  ::google::protobuf::int32 option_;
  friend struct ::protobuf_mensaje_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MyInfoSynchronize

// required string username = 1;
inline bool MyInfoSynchronize::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyInfoSynchronize::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyInfoSynchronize::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyInfoSynchronize::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& MyInfoSynchronize::username() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoSynchronize.username)
  return username_.GetNoArena();
}
inline void MyInfoSynchronize::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MyInfoSynchronize.username)
}
#if LANG_CXX11
inline void MyInfoSynchronize::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.MyInfoSynchronize.username)
}
#endif
inline void MyInfoSynchronize::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MyInfoSynchronize.username)
}
inline void MyInfoSynchronize::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MyInfoSynchronize.username)
}
inline ::std::string* MyInfoSynchronize::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.MyInfoSynchronize.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MyInfoSynchronize::release_username() {
  // @@protoc_insertion_point(field_release:chat.MyInfoSynchronize.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MyInfoSynchronize::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.MyInfoSynchronize.username)
}

// optional string ip = 2;
inline bool MyInfoSynchronize::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyInfoSynchronize::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyInfoSynchronize::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyInfoSynchronize::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& MyInfoSynchronize::ip() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoSynchronize.ip)
  return ip_.GetNoArena();
}
inline void MyInfoSynchronize::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MyInfoSynchronize.ip)
}
#if LANG_CXX11
inline void MyInfoSynchronize::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.MyInfoSynchronize.ip)
}
#endif
inline void MyInfoSynchronize::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MyInfoSynchronize.ip)
}
inline void MyInfoSynchronize::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MyInfoSynchronize.ip)
}
inline ::std::string* MyInfoSynchronize::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:chat.MyInfoSynchronize.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MyInfoSynchronize::release_ip() {
  // @@protoc_insertion_point(field_release:chat.MyInfoSynchronize.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MyInfoSynchronize::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:chat.MyInfoSynchronize.ip)
}

// -------------------------------------------------------------------

// MyInfoResponse

// required int32 userId = 1;
inline bool MyInfoResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyInfoResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyInfoResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyInfoResponse::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 MyInfoResponse::userid() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoResponse.userId)
  return userid_;
}
inline void MyInfoResponse::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.MyInfoResponse.userId)
}

// -------------------------------------------------------------------

// MyInfoAcknowledge

// required int32 userId = 1;
inline bool MyInfoAcknowledge::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyInfoAcknowledge::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyInfoAcknowledge::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyInfoAcknowledge::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 MyInfoAcknowledge::userid() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoAcknowledge.userId)
  return userid_;
}
inline void MyInfoAcknowledge::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.MyInfoAcknowledge.userId)
}

// -------------------------------------------------------------------

// connectedUserRequest

// optional int32 userId = 1;
inline bool connectedUserRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connectedUserRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connectedUserRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connectedUserRequest::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 connectedUserRequest::userid() const {
  // @@protoc_insertion_point(field_get:chat.connectedUserRequest.userId)
  return userid_;
}
inline void connectedUserRequest::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.connectedUserRequest.userId)
}

// optional string username = 2;
inline bool connectedUserRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connectedUserRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connectedUserRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connectedUserRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& connectedUserRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.connectedUserRequest.username)
  return username_.GetNoArena();
}
inline void connectedUserRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.connectedUserRequest.username)
}
#if LANG_CXX11
inline void connectedUserRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.connectedUserRequest.username)
}
#endif
inline void connectedUserRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.connectedUserRequest.username)
}
inline void connectedUserRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.connectedUserRequest.username)
}
inline ::std::string* connectedUserRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.connectedUserRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* connectedUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.connectedUserRequest.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connectedUserRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.connectedUserRequest.username)
}

// -------------------------------------------------------------------

// ConnectedUser

// required string username = 1;
inline bool ConnectedUser::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectedUser::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectedUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectedUser::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& ConnectedUser::username() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.username)
  return username_.GetNoArena();
}
inline void ConnectedUser::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.username)
}
#if LANG_CXX11
inline void ConnectedUser::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ConnectedUser.username)
}
#endif
inline void ConnectedUser::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.username)
}
inline void ConnectedUser::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.username)
}
inline ::std::string* ConnectedUser::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectedUser::release_username() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.username)
}

// optional string status = 2;
inline bool ConnectedUser::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectedUser::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectedUser::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectedUser::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& ConnectedUser::status() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.status)
  return status_.GetNoArena();
}
inline void ConnectedUser::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.status)
}
#if LANG_CXX11
inline void ConnectedUser::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ConnectedUser.status)
}
#endif
inline void ConnectedUser::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.status)
}
inline void ConnectedUser::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.status)
}
inline ::std::string* ConnectedUser::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectedUser::release_status() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.status)
}

// optional int32 userId = 3;
inline bool ConnectedUser::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectedUser::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectedUser::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectedUser::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ConnectedUser::userid() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.userId)
  return userid_;
}
inline void ConnectedUser::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.userId)
}

// optional string ip = 4;
inline bool ConnectedUser::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectedUser::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectedUser::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectedUser::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ConnectedUser::ip() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.ip)
  return ip_.GetNoArena();
}
inline void ConnectedUser::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.ip)
}
#if LANG_CXX11
inline void ConnectedUser::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ConnectedUser.ip)
}
#endif
inline void ConnectedUser::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.ip)
}
inline void ConnectedUser::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.ip)
}
inline ::std::string* ConnectedUser::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectedUser::release_ip() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.ip)
}

// -------------------------------------------------------------------

// ConnectedUserResponse

// repeated .chat.ConnectedUser connectedUsers = 1;
inline int ConnectedUserResponse::connectedusers_size() const {
  return connectedusers_.size();
}
inline void ConnectedUserResponse::clear_connectedusers() {
  connectedusers_.Clear();
}
inline ::chat::ConnectedUser* ConnectedUserResponse::mutable_connectedusers(int index) {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >*
ConnectedUserResponse::mutable_connectedusers() {
  // @@protoc_insertion_point(field_mutable_list:chat.ConnectedUserResponse.connectedUsers)
  return &connectedusers_;
}
inline const ::chat::ConnectedUser& ConnectedUserResponse::connectedusers(int index) const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Get(index);
}
inline ::chat::ConnectedUser* ConnectedUserResponse::add_connectedusers() {
  // @@protoc_insertion_point(field_add:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >&
ConnectedUserResponse::connectedusers() const {
  // @@protoc_insertion_point(field_list:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_;
}

// -------------------------------------------------------------------

// ChangeStatusRequest

// required string status = 1;
inline bool ChangeStatusRequest::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStatusRequest::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStatusRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStatusRequest::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& ChangeStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusRequest.status)
  return status_.GetNoArena();
}
inline void ChangeStatusRequest::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusRequest.status)
}
#if LANG_CXX11
inline void ChangeStatusRequest::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ChangeStatusRequest.status)
}
#endif
inline void ChangeStatusRequest::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatusRequest.status)
}
inline void ChangeStatusRequest::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatusRequest.status)
}
inline ::std::string* ChangeStatusRequest::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatusRequest.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatusRequest::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatusRequest.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusRequest::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatusRequest.status)
}

// -------------------------------------------------------------------

// ChangeStatusResponse

// required int32 userId = 1;
inline bool ChangeStatusResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeStatusResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeStatusResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeStatusResponse::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ChangeStatusResponse::userid() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusResponse.userId)
  return userid_;
}
inline void ChangeStatusResponse::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.ChangeStatusResponse.userId)
}

// required string status = 2;
inline bool ChangeStatusResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStatusResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStatusResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStatusResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& ChangeStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusResponse.status)
  return status_.GetNoArena();
}
inline void ChangeStatusResponse::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusResponse.status)
}
#if LANG_CXX11
inline void ChangeStatusResponse::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ChangeStatusResponse.status)
}
#endif
inline void ChangeStatusResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatusResponse.status)
}
inline void ChangeStatusResponse::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatusResponse.status)
}
inline ::std::string* ChangeStatusResponse::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatusResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatusResponse.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatusResponse.status)
}

// -------------------------------------------------------------------

// BroadcastRequest

// required string message = 1;
inline bool BroadcastRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& BroadcastRequest::message() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastRequest.message)
  return message_.GetNoArena();
}
inline void BroadcastRequest::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastRequest.message)
}
#if LANG_CXX11
inline void BroadcastRequest::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastRequest.message)
}
#endif
inline void BroadcastRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastRequest.message)
}
inline void BroadcastRequest::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastRequest.message)
}
inline ::std::string* BroadcastRequest::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastRequest::release_message() {
  // @@protoc_insertion_point(field_release:chat.BroadcastRequest.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastRequest.message)
}

// -------------------------------------------------------------------

// BroadcastResponse

// required string messageStatus = 1;
inline bool BroadcastResponse::has_messagestatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastResponse::set_has_messagestatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastResponse::clear_has_messagestatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastResponse::clear_messagestatus() {
  messagestatus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagestatus();
}
inline const ::std::string& BroadcastResponse::messagestatus() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastResponse.messageStatus)
  return messagestatus_.GetNoArena();
}
inline void BroadcastResponse::set_messagestatus(const ::std::string& value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastResponse.messageStatus)
}
#if LANG_CXX11
inline void BroadcastResponse::set_messagestatus(::std::string&& value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastResponse.messageStatus)
}
#endif
inline void BroadcastResponse::set_messagestatus(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastResponse.messageStatus)
}
inline void BroadcastResponse::set_messagestatus(const char* value, size_t size) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastResponse.messageStatus)
}
inline ::std::string* BroadcastResponse::mutable_messagestatus() {
  set_has_messagestatus();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastResponse.messageStatus)
  return messagestatus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastResponse::release_messagestatus() {
  // @@protoc_insertion_point(field_release:chat.BroadcastResponse.messageStatus)
  if (!has_messagestatus()) {
    return NULL;
  }
  clear_has_messagestatus();
  return messagestatus_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastResponse::set_allocated_messagestatus(::std::string* messagestatus) {
  if (messagestatus != NULL) {
    set_has_messagestatus();
  } else {
    clear_has_messagestatus();
  }
  messagestatus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagestatus);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastResponse.messageStatus)
}

// -------------------------------------------------------------------

// BroadcastMessage

// required string message = 1;
inline bool BroadcastMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& BroadcastMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.message)
  return message_.GetNoArena();
}
inline void BroadcastMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.message)
}
#if LANG_CXX11
inline void BroadcastMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastMessage.message)
}
#endif
inline void BroadcastMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastMessage.message)
}
inline void BroadcastMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastMessage.message)
}
inline ::std::string* BroadcastMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.BroadcastMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastMessage.message)
}

// required int32 userId = 2;
inline bool BroadcastMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadcastMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadcastMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadcastMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 BroadcastMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.userId)
  return userid_;
}
inline void BroadcastMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.userId)
}

// optional string username = 3;
inline bool BroadcastMessage::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastMessage::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastMessage::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& BroadcastMessage::username() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.username)
  return username_.GetNoArena();
}
inline void BroadcastMessage::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.username)
}
#if LANG_CXX11
inline void BroadcastMessage::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastMessage.username)
}
#endif
inline void BroadcastMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastMessage.username)
}
inline void BroadcastMessage::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastMessage.username)
}
inline ::std::string* BroadcastMessage::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastMessage.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastMessage::release_username() {
  // @@protoc_insertion_point(field_release:chat.BroadcastMessage.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastMessage.username)
}

// -------------------------------------------------------------------

// DirectMessageRequest

// required string message = 1;
inline bool DirectMessageRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectMessageRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectMessageRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectMessageRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DirectMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.message)
  return message_.GetNoArena();
}
inline void DirectMessageRequest::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.message)
}
#if LANG_CXX11
inline void DirectMessageRequest::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessageRequest.message)
}
#endif
inline void DirectMessageRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageRequest.message)
}
inline void DirectMessageRequest::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageRequest.message)
}
inline ::std::string* DirectMessageRequest::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageRequest.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageRequest.message)
}

// optional int32 userId = 2;
inline bool DirectMessageRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectMessageRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectMessageRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectMessageRequest::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 DirectMessageRequest::userid() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.userId)
  return userid_;
}
inline void DirectMessageRequest::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.userId)
}

// optional string username = 3;
inline bool DirectMessageRequest::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectMessageRequest::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectMessageRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectMessageRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& DirectMessageRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.username)
  return username_.GetNoArena();
}
inline void DirectMessageRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.username)
}
#if LANG_CXX11
inline void DirectMessageRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessageRequest.username)
}
#endif
inline void DirectMessageRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageRequest.username)
}
inline void DirectMessageRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageRequest.username)
}
inline ::std::string* DirectMessageRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessageRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageRequest.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageRequest.username)
}

// -------------------------------------------------------------------

// DirectMessageResponse

// required string messageStatus = 1;
inline bool DirectMessageResponse::has_messagestatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectMessageResponse::set_has_messagestatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectMessageResponse::clear_has_messagestatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectMessageResponse::clear_messagestatus() {
  messagestatus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagestatus();
}
inline const ::std::string& DirectMessageResponse::messagestatus() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageResponse.messageStatus)
  return messagestatus_.GetNoArena();
}
inline void DirectMessageResponse::set_messagestatus(const ::std::string& value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageResponse.messageStatus)
}
#if LANG_CXX11
inline void DirectMessageResponse::set_messagestatus(::std::string&& value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessageResponse.messageStatus)
}
#endif
inline void DirectMessageResponse::set_messagestatus(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageResponse.messageStatus)
}
inline void DirectMessageResponse::set_messagestatus(const char* value, size_t size) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageResponse.messageStatus)
}
inline ::std::string* DirectMessageResponse::mutable_messagestatus() {
  set_has_messagestatus();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageResponse.messageStatus)
  return messagestatus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessageResponse::release_messagestatus() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageResponse.messageStatus)
  if (!has_messagestatus()) {
    return NULL;
  }
  clear_has_messagestatus();
  return messagestatus_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageResponse::set_allocated_messagestatus(::std::string* messagestatus) {
  if (messagestatus != NULL) {
    set_has_messagestatus();
  } else {
    clear_has_messagestatus();
  }
  messagestatus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagestatus);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageResponse.messageStatus)
}

// -------------------------------------------------------------------

// DirectMessage

// required string message = 1;
inline bool DirectMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DirectMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.message)
  return message_.GetNoArena();
}
inline void DirectMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessage.message)
}
#if LANG_CXX11
inline void DirectMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessage.message)
}
#endif
inline void DirectMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessage.message)
}
inline void DirectMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessage.message)
}
inline ::std::string* DirectMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.DirectMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessage.message)
}

// required int32 userId = 2;
inline bool DirectMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 DirectMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.userId)
  return userid_;
}
inline void DirectMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.DirectMessage.userId)
}

// optional string username = 3;
inline bool DirectMessage::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectMessage::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectMessage::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& DirectMessage::username() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.username)
  return username_.GetNoArena();
}
inline void DirectMessage::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessage.username)
}
#if LANG_CXX11
inline void DirectMessage::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessage.username)
}
#endif
inline void DirectMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessage.username)
}
inline void DirectMessage::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessage.username)
}
inline ::std::string* DirectMessage::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessage.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessage::release_username() {
  // @@protoc_insertion_point(field_release:chat.DirectMessage.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessage.username)
}

// -------------------------------------------------------------------

// ErrorResponse

// required string errorMessage = 1;
inline bool ErrorResponse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorResponse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorResponse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorResponse::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormessage();
}
inline const ::std::string& ErrorResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:chat.ErrorResponse.errorMessage)
  return errormessage_.GetNoArena();
}
inline void ErrorResponse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ErrorResponse.errorMessage)
}
#if LANG_CXX11
inline void ErrorResponse::set_errormessage(::std::string&& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ErrorResponse.errorMessage)
}
#endif
inline void ErrorResponse::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ErrorResponse.errorMessage)
}
inline ::std::string* ErrorResponse::mutable_errormessage() {
  set_has_errormessage();
  // @@protoc_insertion_point(field_mutable:chat.ErrorResponse.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:chat.ErrorResponse.errorMessage)
  if (!has_errormessage()) {
    return NULL;
  }
  clear_has_errormessage();
  return errormessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorResponse::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:chat.ErrorResponse.errorMessage)
}

// -------------------------------------------------------------------

// ClientMessage

// required int32 option = 1;
inline bool ClientMessage::has_option() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientMessage::set_has_option() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ClientMessage::option() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.option)
  return option_;
}
inline void ClientMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:chat.ClientMessage.option)
}

// optional int32 userId = 2;
inline bool ClientMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ClientMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.userId)
  return userid_;
}
inline void ClientMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.ClientMessage.userId)
}

// optional .chat.MyInfoSynchronize synchronize = 3;
inline bool ClientMessage::has_synchronize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_synchronize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_synchronize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_synchronize() {
  if (synchronize_ != NULL) synchronize_->Clear();
  clear_has_synchronize();
}
inline const ::chat::MyInfoSynchronize& ClientMessage::_internal_synchronize() const {
  return *synchronize_;
}
inline const ::chat::MyInfoSynchronize& ClientMessage::synchronize() const {
  const ::chat::MyInfoSynchronize* p = synchronize_;
  // @@protoc_insertion_point(field_get:chat.ClientMessage.synchronize)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::MyInfoSynchronize*>(
      &::chat::_MyInfoSynchronize_default_instance_);
}
inline ::chat::MyInfoSynchronize* ClientMessage::release_synchronize() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.synchronize)
  clear_has_synchronize();
  ::chat::MyInfoSynchronize* temp = synchronize_;
  synchronize_ = NULL;
  return temp;
}
inline ::chat::MyInfoSynchronize* ClientMessage::mutable_synchronize() {
  set_has_synchronize();
  if (synchronize_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::MyInfoSynchronize>(GetArenaNoVirtual());
    synchronize_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.synchronize)
  return synchronize_;
}
inline void ClientMessage::set_allocated_synchronize(::chat::MyInfoSynchronize* synchronize) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete synchronize_;
  }
  if (synchronize) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      synchronize = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, synchronize, submessage_arena);
    }
    set_has_synchronize();
  } else {
    clear_has_synchronize();
  }
  synchronize_ = synchronize;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.synchronize)
}

// optional .chat.connectedUserRequest connectedUsers = 4;
inline bool ClientMessage::has_connectedusers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_connectedusers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_connectedusers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_connectedusers() {
  if (connectedusers_ != NULL) connectedusers_->Clear();
  clear_has_connectedusers();
}
inline const ::chat::connectedUserRequest& ClientMessage::_internal_connectedusers() const {
  return *connectedusers_;
}
inline const ::chat::connectedUserRequest& ClientMessage::connectedusers() const {
  const ::chat::connectedUserRequest* p = connectedusers_;
  // @@protoc_insertion_point(field_get:chat.ClientMessage.connectedUsers)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::connectedUserRequest*>(
      &::chat::_connectedUserRequest_default_instance_);
}
inline ::chat::connectedUserRequest* ClientMessage::release_connectedusers() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.connectedUsers)
  clear_has_connectedusers();
  ::chat::connectedUserRequest* temp = connectedusers_;
  connectedusers_ = NULL;
  return temp;
}
inline ::chat::connectedUserRequest* ClientMessage::mutable_connectedusers() {
  set_has_connectedusers();
  if (connectedusers_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::connectedUserRequest>(GetArenaNoVirtual());
    connectedusers_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.connectedUsers)
  return connectedusers_;
}
inline void ClientMessage::set_allocated_connectedusers(::chat::connectedUserRequest* connectedusers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connectedusers_;
  }
  if (connectedusers) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connectedusers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connectedusers, submessage_arena);
    }
    set_has_connectedusers();
  } else {
    clear_has_connectedusers();
  }
  connectedusers_ = connectedusers;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.connectedUsers)
}

// optional .chat.ChangeStatusRequest changeStatus = 5;
inline bool ClientMessage::has_changestatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_changestatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_changestatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_changestatus() {
  if (changestatus_ != NULL) changestatus_->Clear();
  clear_has_changestatus();
}
inline const ::chat::ChangeStatusRequest& ClientMessage::_internal_changestatus() const {
  return *changestatus_;
}
inline const ::chat::ChangeStatusRequest& ClientMessage::changestatus() const {
  const ::chat::ChangeStatusRequest* p = changestatus_;
  // @@protoc_insertion_point(field_get:chat.ClientMessage.changeStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ChangeStatusRequest*>(
      &::chat::_ChangeStatusRequest_default_instance_);
}
inline ::chat::ChangeStatusRequest* ClientMessage::release_changestatus() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.changeStatus)
  clear_has_changestatus();
  ::chat::ChangeStatusRequest* temp = changestatus_;
  changestatus_ = NULL;
  return temp;
}
inline ::chat::ChangeStatusRequest* ClientMessage::mutable_changestatus() {
  set_has_changestatus();
  if (changestatus_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ChangeStatusRequest>(GetArenaNoVirtual());
    changestatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.changeStatus)
  return changestatus_;
}
inline void ClientMessage::set_allocated_changestatus(::chat::ChangeStatusRequest* changestatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete changestatus_;
  }
  if (changestatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      changestatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changestatus, submessage_arena);
    }
    set_has_changestatus();
  } else {
    clear_has_changestatus();
  }
  changestatus_ = changestatus;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.changeStatus)
}

// optional .chat.BroadcastRequest broadcast = 6;
inline bool ClientMessage::has_broadcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientMessage::set_has_broadcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientMessage::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientMessage::clear_broadcast() {
  if (broadcast_ != NULL) broadcast_->Clear();
  clear_has_broadcast();
}
inline const ::chat::BroadcastRequest& ClientMessage::_internal_broadcast() const {
  return *broadcast_;
}
inline const ::chat::BroadcastRequest& ClientMessage::broadcast() const {
  const ::chat::BroadcastRequest* p = broadcast_;
  // @@protoc_insertion_point(field_get:chat.ClientMessage.broadcast)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::BroadcastRequest*>(
      &::chat::_BroadcastRequest_default_instance_);
}
inline ::chat::BroadcastRequest* ClientMessage::release_broadcast() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.broadcast)
  clear_has_broadcast();
  ::chat::BroadcastRequest* temp = broadcast_;
  broadcast_ = NULL;
  return temp;
}
inline ::chat::BroadcastRequest* ClientMessage::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::BroadcastRequest>(GetArenaNoVirtual());
    broadcast_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.broadcast)
  return broadcast_;
}
inline void ClientMessage::set_allocated_broadcast(::chat::BroadcastRequest* broadcast) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete broadcast_;
  }
  if (broadcast) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      broadcast = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    set_has_broadcast();
  } else {
    clear_has_broadcast();
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.broadcast)
}

// optional .chat.DirectMessageRequest directMessage = 7;
inline bool ClientMessage::has_directmessage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientMessage::set_has_directmessage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientMessage::clear_has_directmessage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientMessage::clear_directmessage() {
  if (directmessage_ != NULL) directmessage_->Clear();
  clear_has_directmessage();
}
inline const ::chat::DirectMessageRequest& ClientMessage::_internal_directmessage() const {
  return *directmessage_;
}
inline const ::chat::DirectMessageRequest& ClientMessage::directmessage() const {
  const ::chat::DirectMessageRequest* p = directmessage_;
  // @@protoc_insertion_point(field_get:chat.ClientMessage.directMessage)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::DirectMessageRequest*>(
      &::chat::_DirectMessageRequest_default_instance_);
}
inline ::chat::DirectMessageRequest* ClientMessage::release_directmessage() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.directMessage)
  clear_has_directmessage();
  ::chat::DirectMessageRequest* temp = directmessage_;
  directmessage_ = NULL;
  return temp;
}
inline ::chat::DirectMessageRequest* ClientMessage::mutable_directmessage() {
  set_has_directmessage();
  if (directmessage_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::DirectMessageRequest>(GetArenaNoVirtual());
    directmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.directMessage)
  return directmessage_;
}
inline void ClientMessage::set_allocated_directmessage(::chat::DirectMessageRequest* directmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete directmessage_;
  }
  if (directmessage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      directmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, directmessage, submessage_arena);
    }
    set_has_directmessage();
  } else {
    clear_has_directmessage();
  }
  directmessage_ = directmessage;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.directMessage)
}

// optional .chat.MyInfoAcknowledge acknowledge = 8;
inline bool ClientMessage::has_acknowledge() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientMessage::set_has_acknowledge() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientMessage::clear_has_acknowledge() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientMessage::clear_acknowledge() {
  if (acknowledge_ != NULL) acknowledge_->Clear();
  clear_has_acknowledge();
}
inline const ::chat::MyInfoAcknowledge& ClientMessage::_internal_acknowledge() const {
  return *acknowledge_;
}
inline const ::chat::MyInfoAcknowledge& ClientMessage::acknowledge() const {
  const ::chat::MyInfoAcknowledge* p = acknowledge_;
  // @@protoc_insertion_point(field_get:chat.ClientMessage.acknowledge)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::MyInfoAcknowledge*>(
      &::chat::_MyInfoAcknowledge_default_instance_);
}
inline ::chat::MyInfoAcknowledge* ClientMessage::release_acknowledge() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.acknowledge)
  clear_has_acknowledge();
  ::chat::MyInfoAcknowledge* temp = acknowledge_;
  acknowledge_ = NULL;
  return temp;
}
inline ::chat::MyInfoAcknowledge* ClientMessage::mutable_acknowledge() {
  set_has_acknowledge();
  if (acknowledge_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::MyInfoAcknowledge>(GetArenaNoVirtual());
    acknowledge_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.acknowledge)
  return acknowledge_;
}
inline void ClientMessage::set_allocated_acknowledge(::chat::MyInfoAcknowledge* acknowledge) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acknowledge_;
  }
  if (acknowledge) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acknowledge = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acknowledge, submessage_arena);
    }
    set_has_acknowledge();
  } else {
    clear_has_acknowledge();
  }
  acknowledge_ = acknowledge;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.acknowledge)
}

// -------------------------------------------------------------------

// ServerMessage

// required int32 option = 1;
inline bool ServerMessage::has_option() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerMessage::set_has_option() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ServerMessage::option() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.option)
  return option_;
}
inline void ServerMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:chat.ServerMessage.option)
}

// optional .chat.BroadcastMessage broadcast = 2;
inline bool ServerMessage::has_broadcast() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_broadcast() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_broadcast() {
  if (broadcast_ != NULL) broadcast_->Clear();
  clear_has_broadcast();
}
inline const ::chat::BroadcastMessage& ServerMessage::_internal_broadcast() const {
  return *broadcast_;
}
inline const ::chat::BroadcastMessage& ServerMessage::broadcast() const {
  const ::chat::BroadcastMessage* p = broadcast_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.broadcast)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::BroadcastMessage*>(
      &::chat::_BroadcastMessage_default_instance_);
}
inline ::chat::BroadcastMessage* ServerMessage::release_broadcast() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.broadcast)
  clear_has_broadcast();
  ::chat::BroadcastMessage* temp = broadcast_;
  broadcast_ = NULL;
  return temp;
}
inline ::chat::BroadcastMessage* ServerMessage::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::BroadcastMessage>(GetArenaNoVirtual());
    broadcast_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.broadcast)
  return broadcast_;
}
inline void ServerMessage::set_allocated_broadcast(::chat::BroadcastMessage* broadcast) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete broadcast_;
  }
  if (broadcast) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      broadcast = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    set_has_broadcast();
  } else {
    clear_has_broadcast();
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.broadcast)
}

// optional .chat.DirectMessage message = 3;
inline bool ServerMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_message() {
  if (message_ != NULL) message_->Clear();
  clear_has_message();
}
inline const ::chat::DirectMessage& ServerMessage::_internal_message() const {
  return *message_;
}
inline const ::chat::DirectMessage& ServerMessage::message() const {
  const ::chat::DirectMessage* p = message_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.message)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::DirectMessage*>(
      &::chat::_DirectMessage_default_instance_);
}
inline ::chat::DirectMessage* ServerMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.message)
  clear_has_message();
  ::chat::DirectMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline ::chat::DirectMessage* ServerMessage::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::DirectMessage>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.message)
  return message_;
}
inline void ServerMessage::set_allocated_message(::chat::DirectMessage* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete message_;
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    set_has_message();
  } else {
    clear_has_message();
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.message)
}

// optional .chat.ErrorResponse error = 4;
inline bool ServerMessage::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMessage::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMessage::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMessage::clear_error() {
  if (error_ != NULL) error_->Clear();
  clear_has_error();
}
inline const ::chat::ErrorResponse& ServerMessage::_internal_error() const {
  return *error_;
}
inline const ::chat::ErrorResponse& ServerMessage::error() const {
  const ::chat::ErrorResponse* p = error_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.error)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ErrorResponse*>(
      &::chat::_ErrorResponse_default_instance_);
}
inline ::chat::ErrorResponse* ServerMessage::release_error() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.error)
  clear_has_error();
  ::chat::ErrorResponse* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::chat::ErrorResponse* ServerMessage::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ErrorResponse>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.error)
  return error_;
}
inline void ServerMessage::set_allocated_error(::chat::ErrorResponse* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.error)
}

// optional .chat.MyInfoResponse myInfoResponse = 5;
inline bool ServerMessage::has_myinforesponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerMessage::set_has_myinforesponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerMessage::clear_has_myinforesponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerMessage::clear_myinforesponse() {
  if (myinforesponse_ != NULL) myinforesponse_->Clear();
  clear_has_myinforesponse();
}
inline const ::chat::MyInfoResponse& ServerMessage::_internal_myinforesponse() const {
  return *myinforesponse_;
}
inline const ::chat::MyInfoResponse& ServerMessage::myinforesponse() const {
  const ::chat::MyInfoResponse* p = myinforesponse_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.myInfoResponse)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::MyInfoResponse*>(
      &::chat::_MyInfoResponse_default_instance_);
}
inline ::chat::MyInfoResponse* ServerMessage::release_myinforesponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.myInfoResponse)
  clear_has_myinforesponse();
  ::chat::MyInfoResponse* temp = myinforesponse_;
  myinforesponse_ = NULL;
  return temp;
}
inline ::chat::MyInfoResponse* ServerMessage::mutable_myinforesponse() {
  set_has_myinforesponse();
  if (myinforesponse_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::MyInfoResponse>(GetArenaNoVirtual());
    myinforesponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.myInfoResponse)
  return myinforesponse_;
}
inline void ServerMessage::set_allocated_myinforesponse(::chat::MyInfoResponse* myinforesponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete myinforesponse_;
  }
  if (myinforesponse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      myinforesponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, myinforesponse, submessage_arena);
    }
    set_has_myinforesponse();
  } else {
    clear_has_myinforesponse();
  }
  myinforesponse_ = myinforesponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.myInfoResponse)
}

// optional .chat.ConnectedUserResponse connectedUserResponse = 6;
inline bool ServerMessage::has_connecteduserresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerMessage::set_has_connecteduserresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerMessage::clear_has_connecteduserresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerMessage::clear_connecteduserresponse() {
  if (connecteduserresponse_ != NULL) connecteduserresponse_->Clear();
  clear_has_connecteduserresponse();
}
inline const ::chat::ConnectedUserResponse& ServerMessage::_internal_connecteduserresponse() const {
  return *connecteduserresponse_;
}
inline const ::chat::ConnectedUserResponse& ServerMessage::connecteduserresponse() const {
  const ::chat::ConnectedUserResponse* p = connecteduserresponse_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.connectedUserResponse)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ConnectedUserResponse*>(
      &::chat::_ConnectedUserResponse_default_instance_);
}
inline ::chat::ConnectedUserResponse* ServerMessage::release_connecteduserresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.connectedUserResponse)
  clear_has_connecteduserresponse();
  ::chat::ConnectedUserResponse* temp = connecteduserresponse_;
  connecteduserresponse_ = NULL;
  return temp;
}
inline ::chat::ConnectedUserResponse* ServerMessage::mutable_connecteduserresponse() {
  set_has_connecteduserresponse();
  if (connecteduserresponse_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ConnectedUserResponse>(GetArenaNoVirtual());
    connecteduserresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.connectedUserResponse)
  return connecteduserresponse_;
}
inline void ServerMessage::set_allocated_connecteduserresponse(::chat::ConnectedUserResponse* connecteduserresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connecteduserresponse_;
  }
  if (connecteduserresponse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connecteduserresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connecteduserresponse, submessage_arena);
    }
    set_has_connecteduserresponse();
  } else {
    clear_has_connecteduserresponse();
  }
  connecteduserresponse_ = connecteduserresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.connectedUserResponse)
}

// optional .chat.ChangeStatusResponse changeStatusResponse = 7;
inline bool ServerMessage::has_changestatusresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerMessage::set_has_changestatusresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerMessage::clear_has_changestatusresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerMessage::clear_changestatusresponse() {
  if (changestatusresponse_ != NULL) changestatusresponse_->Clear();
  clear_has_changestatusresponse();
}
inline const ::chat::ChangeStatusResponse& ServerMessage::_internal_changestatusresponse() const {
  return *changestatusresponse_;
}
inline const ::chat::ChangeStatusResponse& ServerMessage::changestatusresponse() const {
  const ::chat::ChangeStatusResponse* p = changestatusresponse_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.changeStatusResponse)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ChangeStatusResponse*>(
      &::chat::_ChangeStatusResponse_default_instance_);
}
inline ::chat::ChangeStatusResponse* ServerMessage::release_changestatusresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.changeStatusResponse)
  clear_has_changestatusresponse();
  ::chat::ChangeStatusResponse* temp = changestatusresponse_;
  changestatusresponse_ = NULL;
  return temp;
}
inline ::chat::ChangeStatusResponse* ServerMessage::mutable_changestatusresponse() {
  set_has_changestatusresponse();
  if (changestatusresponse_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ChangeStatusResponse>(GetArenaNoVirtual());
    changestatusresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.changeStatusResponse)
  return changestatusresponse_;
}
inline void ServerMessage::set_allocated_changestatusresponse(::chat::ChangeStatusResponse* changestatusresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete changestatusresponse_;
  }
  if (changestatusresponse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      changestatusresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, changestatusresponse, submessage_arena);
    }
    set_has_changestatusresponse();
  } else {
    clear_has_changestatusresponse();
  }
  changestatusresponse_ = changestatusresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.changeStatusResponse)
}

// optional .chat.BroadcastResponse broadcastResponse = 8;
inline bool ServerMessage::has_broadcastresponse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerMessage::set_has_broadcastresponse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerMessage::clear_has_broadcastresponse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerMessage::clear_broadcastresponse() {
  if (broadcastresponse_ != NULL) broadcastresponse_->Clear();
  clear_has_broadcastresponse();
}
inline const ::chat::BroadcastResponse& ServerMessage::_internal_broadcastresponse() const {
  return *broadcastresponse_;
}
inline const ::chat::BroadcastResponse& ServerMessage::broadcastresponse() const {
  const ::chat::BroadcastResponse* p = broadcastresponse_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.broadcastResponse)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::BroadcastResponse*>(
      &::chat::_BroadcastResponse_default_instance_);
}
inline ::chat::BroadcastResponse* ServerMessage::release_broadcastresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.broadcastResponse)
  clear_has_broadcastresponse();
  ::chat::BroadcastResponse* temp = broadcastresponse_;
  broadcastresponse_ = NULL;
  return temp;
}
inline ::chat::BroadcastResponse* ServerMessage::mutable_broadcastresponse() {
  set_has_broadcastresponse();
  if (broadcastresponse_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::BroadcastResponse>(GetArenaNoVirtual());
    broadcastresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.broadcastResponse)
  return broadcastresponse_;
}
inline void ServerMessage::set_allocated_broadcastresponse(::chat::BroadcastResponse* broadcastresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete broadcastresponse_;
  }
  if (broadcastresponse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      broadcastresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, broadcastresponse, submessage_arena);
    }
    set_has_broadcastresponse();
  } else {
    clear_has_broadcastresponse();
  }
  broadcastresponse_ = broadcastresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.broadcastResponse)
}

// optional .chat.DirectMessageResponse directMessageResponse = 9;
inline bool ServerMessage::has_directmessageresponse() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerMessage::set_has_directmessageresponse() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerMessage::clear_has_directmessageresponse() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerMessage::clear_directmessageresponse() {
  if (directmessageresponse_ != NULL) directmessageresponse_->Clear();
  clear_has_directmessageresponse();
}
inline const ::chat::DirectMessageResponse& ServerMessage::_internal_directmessageresponse() const {
  return *directmessageresponse_;
}
inline const ::chat::DirectMessageResponse& ServerMessage::directmessageresponse() const {
  const ::chat::DirectMessageResponse* p = directmessageresponse_;
  // @@protoc_insertion_point(field_get:chat.ServerMessage.directMessageResponse)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::DirectMessageResponse*>(
      &::chat::_DirectMessageResponse_default_instance_);
}
inline ::chat::DirectMessageResponse* ServerMessage::release_directmessageresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.directMessageResponse)
  clear_has_directmessageresponse();
  ::chat::DirectMessageResponse* temp = directmessageresponse_;
  directmessageresponse_ = NULL;
  return temp;
}
inline ::chat::DirectMessageResponse* ServerMessage::mutable_directmessageresponse() {
  set_has_directmessageresponse();
  if (directmessageresponse_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::DirectMessageResponse>(GetArenaNoVirtual());
    directmessageresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.directMessageResponse)
  return directmessageresponse_;
}
inline void ServerMessage::set_allocated_directmessageresponse(::chat::DirectMessageResponse* directmessageresponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete directmessageresponse_;
  }
  if (directmessageresponse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      directmessageresponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, directmessageresponse, submessage_arena);
    }
    set_has_directmessageresponse();
  } else {
    clear_has_directmessageresponse();
  }
  directmessageresponse_ = directmessageresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.directMessageResponse)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mensaje_2eproto
